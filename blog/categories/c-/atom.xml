<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C# | Me:ICanWriteCode]]></title>
  <link href="http://prashantvc.github.com/blog/categories/c-/atom.xml" rel="self"/>
  <link href="http://prashantvc.github.com/"/>
  <updated>2013-03-08T23:26:35+05:30</updated>
  <id>http://prashantvc.github.com/</id>
  <author>
    <name><![CDATA[Prashant Cholachagudda]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Where.FirstOrDefault vs FirstOrDefault]]></title>
    <link href="http://prashantvc.github.com/blog/2013/03/07/where-dot-firstordefaulr-vs-firstordefault/"/>
    <updated>2013-03-07T17:39:00+05:30</updated>
    <id>http://prashantvc.github.com/blog/2013/03/07/where-dot-firstordefaulr-vs-firstordefault</id>
    <content type="html"><![CDATA[<p>Use of 1. <code>Where(predicate).FirstOrDefault</code> vs. 2. <code>FirstOrDefault(predicate)</code> came up quite a lot during the recent code reviews. While both yields same result most of the team members preferred using option 2.</p>

<p>I thought <code>FirstOrDefault</code> would execute faster than <code>Where.FirstOrDefault</code>, because the LINQ doesn't need to filter the collection before it calls the <code>FirstOrDefault</code>, and I was <strong>wrong!</strong>.</p>

<p>The <a href="https://www.simple-talk.com/dotnet/.net-framework/linq-secrets-revealed-chaining-and-debugging/" title="LINQ Secrets Revealed: Chaining and Debugging">chaining behaviour</a> of Linq to objects makes sure that collections iterated lazily, so both <code>Where(predicate).FirstOrDefault</code> and <code>FirstOrDefault(predicate)</code> methods won't go further if the first item is hit.</p>

<p>Consider this code snippet,</p>

<p>``` csharp</p>

<pre><code>var items = new[] { 1, 2, 3, 4, 5, 2 };
Func&lt;int, bool&gt; predicate = delegate(int i)
    {
        Console.WriteLine(i);
        return i == 2;
    };

//Prints: 1 2
items.Where(predicate).FirstOrDefault();

//Prints: 1 2    
items.FirstOrDefault(predicate);
</code></pre>

<p>```</p>

<p>I expected the <code>items.Where(predicate).FirstOrDefault()</code> would print all the items in the sequence, but it did not, it returned after printing <code>1 2</code>. So, in the end it doesn't matter what method you use the result and execution will be same and any performance difference are highly insignificant.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Monotouch: UIView to Image]]></title>
    <link href="http://prashantvc.github.com/blog/2013/02/25/monotouch-uiview-to-image/"/>
    <updated>2013-02-25T22:49:00+05:30</updated>
    <id>http://prashantvc.github.com/blog/2013/02/25/monotouch-uiview-to-image</id>
    <content type="html"><![CDATA[<p>I wrote this code snippet quite a while ago to make it easy to print a
UIView from a iOS device. Hope it helps you too.</p>

<p>``` csharp UIViewToImage.cs https://gist.github.com/prashantvc/4657263/raw/a64b8a821b860201e0420c3e735326f80063386a/UIViewToImage.cs View Raw
public static class Extensions
{</p>

<pre><code>public static UIImage ToImage (this UIView view)
{
    RectangleF canvasRect = view.Bounds;
    UIGraphics.BeginImageContextWithOptions (canvasRect.Size, false, 0.0f);

    CGContext ctx = UIGraphics.GetCurrentContext ();
    ctx.FillRect (canvasRect);
    view.Layer.RenderInContext (ctx);

    UIImage newImage = UIGraphics.GetImageFromCurrentImageContext ();
    UIGraphics.EndImageContext ();
    NSData imgData = newImage.AsPNG ();

    return UIImage.LoadFromData (imgData);
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>
